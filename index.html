<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Asteroids</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        canvas {
            border: 1px solid #333;
            background: #000;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00FFFF;
            font-size: clamp(16px, 5vw, 20px); /* Increased for mobile readability */
            text-shadow: 0 0 5px #00FFFF;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FF00FF;
            font-size: clamp(24px, 6vw, 32px);
            text-align: center;
            display: none;
            text-shadow: 0 0 10px #FF00FF;
        }
        #gameOver div {
            font-size: clamp(14px, 3.5vw, 18px);
            margin-top: 15px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            padding-bottom: env(safe-area-inset-bottom, 10px);
            padding-left: env(safe-area-inset-left, 10px);
            padding-right: env(safe-area-inset-right, 10px);
            box-sizing: border-box;
        }
        .control-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            color: #00FFFF;
            font-size: clamp(12px, 3vw, 14px);
            padding: 10px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }
        .control-btn:active {
            background: rgba(0, 255, 255, 0.5);
        }
        @media (max-width: 600px) {
            #ui {
                font-size: clamp(14px, 4vw, 18px); /* Slightly larger for small screens */
            }
            #gameOver {
                font-size: clamp(20px, 5vw, 28px);
            }
            #gameOver div {
                font-size: clamp(12px, 3vw, 16px);
            }
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: clamp(10px, 2.5vw, 12px);
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div>SCORE: <span id="score">0</span></div>
        <div>LIVES: <span id="lives">3</span></div>
    </div>
    <div id="gameOver">
        <div>GAME OVER</div>
        <div>Tap to restart</div>
    </div>
    <div id="controls">
        <div class="control-btn" id="leftBtn">Left</div>
        <div class="control-btn" id="rightBtn">Right</div>
        <div class="control-btn" id="thrustBtn">Thrust</div>
        <div class="control-btn" id="fireBtn">Fire</div>
        <div class="control-btn" id="hyperBtn">Hyper</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const NUM_STARS = 80;

        // Dynamic canvas sizing to prevent stretching
        let resizeTimeout;
        function resizeCanvas() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const dpr = window.devicePixelRatio || 1;
                const aspectRatio = 4 / 3;
                let width = window.innerWidth * 0.95; // 95% to account for safe areas
                let height = window.innerHeight * 0.9; // 90% of height for safe areas
                // Maintain aspect ratio without stretching
                if (width / height > aspectRatio) {
                    width = height * aspectRatio;
                } else {
                    height = width / aspectRatio;
                }
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                ctx.scale(dpr, dpr);
                // Center ship in logical coordinates
                ship.x = width / 2;
                ship.y = height / 2;
            }, 100);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Audio Context initialization
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        document.addEventListener('touchstart', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => console.log('AudioContext resumed'));
            }
        }, { once: true });

        let thrustOscillator = null;
        let thrustGain = null;

        function playLaserSound() {
            if (audioCtx.state !== 'running') return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        function playEnemyLaserSound() {
            if (audioCtx.state !== 'running') return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.15);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        function playExplosionSound(size) {
            if (audioCtx.state !== 'running') return;
            const duration = size === 50 ? 0.3 : size === 25 ? 0.2 : 0.15;
            const baseFreq = size === 50 ? 80 : size === 25 ? 120 : 180;
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(baseFreq * 3, audioCtx.currentTime);
            noiseFilter.frequency.exponentialRampToValueAtTime(baseFreq, audioCtx.currentTime + duration);
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            const bass = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            bass.type = 'sine';
            bass.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
            bass.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + duration);
            bassGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            bassGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            bass.connect(bassGain);
            bassGain.connect(audioCtx.destination);
            noise.start(audioCtx.currentTime);
            bass.start(audioCtx.currentTime);
            noise.stop(audioCtx.currentTime + duration);
            bass.stop(audioCtx.currentTime + duration);
        }

        function startThrustSound() {
            if (audioCtx.state !== 'running') return;
            if (thrustOscillator) return;
            thrustOscillator = audioCtx.createOscillator();
            thrustGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            thrustOscillator.type = 'sawtooth';
            thrustOscillator.frequency.setValueAtTime(60, audioCtx.currentTime);
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300, audioCtx.currentTime);
            thrustGain.gain.setValueAtTime(0, audioCtx.currentTime);
            thrustGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.05);
            thrustOscillator.connect(filter);
            filter.connect(thrustGain);
            thrustGain.connect(audioCtx.destination);
            thrustOscillator.start();
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.frequency.setValueAtTime(30, audioCtx.currentTime);
            lfoGain.gain.setValueAtTime(15, audioCtx.currentTime);
            lfo.connect(lfoGain);
            lfoGain.connect(thrustOscillator.frequency);
            lfo.start();
            thrustOscillator.lfo = lfo;
        }

        function stopThrustSound() {
            if (!thrustOscillator) return;
            thrustGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
            setTimeout(() => {
                if (thrustOscillator) {
                    if (thrustOscillator.lfo) thrustOscillator.lfo.stop();
                    thrustOscillator.stop();
                    thrustOscillator = null;
                    thrustGain = null;
                }
            }, 50);
        }

        function playHyperspaceSound() {
            if (audioCtx.state !== 'running') return;
            const duration = 0.5;
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc1.type = 'sine';
            osc2.type = 'sine';
            osc1.frequency.setValueAtTime(1000, audioCtx.currentTime);
            osc1.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + duration);
            osc2.frequency.setValueAtTime(1200, audioCtx.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + duration);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc1.start(audioCtx.currentTime);
            osc2.start(audioCtx.currentTime);
            osc1.stop(audioCtx.currentTime + duration);
            osc2.stop(audioCtx.currentTime + duration);
            const warble = audioCtx.createOscillator();
            const warbleGain = audioCtx.createGain();
            warble.frequency.setValueAtTime(8, audioCtx.currentTime);
            warbleGain.gain.setValueAtTime(100, audioCtx.currentTime);
            warble.connect(warbleGain);
            warbleGain.connect(osc1.frequency);
            warbleGain.connect(osc2.frequency);
            warble.start(audioCtx.currentTime);
            warble.stop(audioCtx.currentTime + duration);
        }

        function playShipExplosionSound() {
            if (audioCtx.state !== 'running') return;
            const duration = 0.5;
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(500, audioCtx.currentTime);
            noiseFilter.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + duration);
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            const bass = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            bass.type = 'sine';
            bass.frequency.setValueAtTime(80, audioCtx.currentTime);
            bass.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + duration);
            bassGain.gain.setValueAtTime(0.7, audioCtx.currentTime);
            bassGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            bass.connect(bassGain);
            bassGain.connect(audioCtx.destination);
            noise.start(audioCtx.currentTime);
            bass.start(audioCtx.currentTime);
            noise.stop(audioCtx.currentTime + duration);
            bass.stop(audioCtx.currentTime + duration);
        }

        function playRumbleSound() {
            if (audioCtx.state !== 'running') return;
            const duration = 0.2;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(40, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + duration);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + duration);
        }

        const game = {
            score: 0,
            lives: 3,
            level: 1,
            gameOver: false,
            invulnerable: 0
        };

        const ship = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: -Math.PI / 2,
            radius: 15,
            thrust: false,
            thrusting: 0,
            wasThrusting: false
        };

        const keys = {};
        const touchControls = {
            left: false,
            right: false,
            thrust: false,
            fire: false,
            hyper: false,
            hyperUsed: false
        };
        const bullets = [];
        const asteroids = [];
        const particles = [];
        const saucers = [];
        const enemyBullets = [];
        let saucerSpawnTimer = 0;
        const SAUCER_SPAWN_INTERVAL = 1000;
        const stars = [];
        let lastRumble = 0;
        const RUMBLE_DELAY = 120;
        let lastShot = 0;
        const shotDelay = 250;

        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const thrustBtn = document.getElementById('thrustBtn');
        const fireBtn = document.getElementById('fireBtn');
        const hyperBtn = document.getElementById('hyperBtn');

        function handleTouch(e, state) {
            e.preventDefault();
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const btnId = e.target.id;
            if (btnId === 'leftBtn') touchControls.left = state;
            if (btnId === 'rightBtn') touchControls.right = state;
            if (btnId === 'thrustBtn') touchControls.thrust = state;
            if (btnId === 'fireBtn') touchControls.fire = state;
            if (btnId === 'hyperBtn') touchControls.hyper = state;
        }

        leftBtn.addEventListener('touchstart', (e) => handleTouch(e, true), { passive: false });
        rightBtn.addEventListener('touchstart', (e) => handleTouch(e, true), { passive: false });
        thrustBtn.addEventListener('touchstart', (e) => handleTouch(e, true), { passive: false });
        fireBtn.addEventListener('touchstart', (e) => handleTouch(e, true), { passive: false });
        hyperBtn.addEventListener('touchstart', (e) => handleTouch(e, true), { passive: false });
        leftBtn.addEventListener('touchend', (e) => handleTouch(e, false), { passive: false });
        rightBtn.addEventListener('touchend', (e) => handleTouch(e, false), { passive: false });
        thrustBtn.addEventListener('touchend', (e) => handleTouch(e, false), { passive: false });
        fireBtn.addEventListener('touchend', (e) => handleTouch(e, false), { passive: false });
        hyperBtn.addEventListener('touchend', (e) => handleTouch(e, false), { passive: false });

        window.addEventListener('keydown', e => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            keys[e.key] = true;
            if (e.key === ' ') e.preventDefault();
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });

        const gameOverScreen = document.getElementById('gameOver');
        function restartGame() {
            if (game.gameOver) {
                game.gameOver = false;
                game.score = 0;
                game.lives = 3;
                game.level = 1;
                ship.x = canvas.width / (2 * (window.devicePixelRatio || 1));
                ship.y = canvas.height / (2 * (window.devicePixelRatio || 1));
                ship.vx = 0;
                ship.vy = 0;
                ship.angle = -Math.PI / 2;
                initLevel();
                document.getElementById('gameOver').style.display = 'none';
            }
        }
        gameOverScreen.addEventListener('touchstart', restartGame, { passive: false });
        gameOverScreen.addEventListener('click', restartGame);

        function initStars() {
            stars.length = 0;
            for (let i = 0; i < NUM_STARS; i++) {
                const z = Math.random();
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: z * 1.5 + 1,
                    speed: z * 1.5 + 0.5,
                    alpha: z * 0.4 + 0.3
                });
            }
        }

        function createAsteroid(x, y, size) {
            const points = 8 + Math.floor(Math.random() * 4);
            const vertices = [];
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const radius = size * (0.7 + Math.random() * 0.3);
                vertices.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }
            // Ensure asteroids spawn fully within canvas bounds
            const buffer = size; // Buffer to keep asteroids fully on-screen
            return {
                x: x ? x : Math.random() * (canvas.width - 2 * buffer) + buffer,
                y: y ? y : Math.random() * (canvas.height - 2 * buffer) + buffer,
                vx: (Math.random() - 0.5) * (size === 50 ? 1 : size === 25 ? 1.5 : 2),
                vy: (Math.random() - 0.5) * (size === 50 ? 1 : size === 25 ? 1.5 : 2),
                angle: Math.random() * Math.PI * 2,
                rotation: (Math.random() - 0.5) * 0.02,
                size: size,
                vertices: vertices
            };
        }

        function spawnSaucer() {
            if (saucers.length > 0) return;
            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            const speed = 1.5 + game.level * 0.2;
            if (side === 0) {
                x = Math.random() * canvas.width;
                y = -30;
                vx = (Math.random() - 0.5) * 1;
                vy = speed;
            } else if (side === 1) {
                x = Math.random() * canvas.width;
                y = canvas.height + 30;
                vx = (Math.random() - 0.5) * 1;
                vy = -speed;
            } else if (side === 2) {
                x = -30;
                y = Math.random() * canvas.height;
                vx = speed;
                vy = (Math.random() - 0.5) * 1;
            } else {
                x = canvas.width + 30;
                y = Math.random() * canvas.height;
                vx = -speed;
                vy = (Math.random() - 0.5) * 1;
            }
            saucers.push({
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                radius: 15,
                color: '#FF00FF',
                lastShot: 0,
                shotDelay: 100 - (game.level * 5),
                size: 15
            });
        }

        function initLevel() {
            asteroids.length = 0;
            bullets.length = 0;
            saucers.length = 0;
            enemyBullets.length = 0;
            saucerSpawnTimer = 0;
            const numAsteroids = 3 + game.level;
            for (let i = 0; i < numAsteroids; i++) {
                let x, y;
                do {
                    x = Math.random() * (canvas.width - 100) + 50; // Buffer for large asteroids
                    y = Math.random() * (canvas.height - 100) + 50;
                } while (Math.hypot(x - ship.x, y - ship.y) < 150);
                asteroids.push(createAsteroid(x, y, 50));
            }
        }

        function createParticles(x, y, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30
                });
            }
        }

        function drawShip() {
            if (game.invulnerable > 0 && Math.floor(game.invulnerable / 5) % 2 === 0) {
                return;
            }
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            ctx.strokeStyle = '#00FFFF';
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, -10);
            ctx.lineTo(-7, 0);
            ctx.lineTo(-10, 10);
            ctx.closePath();
            ctx.stroke();
            if (ship.thrust && Math.floor(ship.thrusting / 3) % 2 === 0) {
                ctx.strokeStyle = '#FF00FF';
                ctx.shadowColor = '#FF00FF';
                ctx.beginPath();
                ctx.moveTo(-7, -5);
                ctx.lineTo(-15, 0);
                ctx.lineTo(-7, 5);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawSaucer(saucer) {
            ctx.save();
            ctx.translate(saucer.x, saucer.y);
            ctx.strokeStyle = saucer.color;
            ctx.shadowColor = saucer.color;
            ctx.shadowBlur = 8;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, 0, 15, 8, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-10, 0);
            ctx.lineTo(10, 0);
            ctx.lineTo(5, 5);
            ctx.lineTo(-5, 5);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }

        function drawAsteroid(asteroid) {
            ctx.save();
            ctx.translate(asteroid.x, asteroid.y);
            ctx.rotate(asteroid.angle);
            ctx.strokeStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(asteroid.vertices[0].x, asteroid.vertices[0].y);
            for (let i = 1; i < asteroid.vertices.length; i++) {
                ctx.lineTo(asteroid.vertices[i].x, asteroid.vertices[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }

        function drawBullet(bullet) {
            ctx.fillStyle = '#00FFFF';
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 8; // Increased for visibility
            ctx.fillRect(bullet.x - 3, bullet.y - 1.5, 6, 3); // Larger bullet: 6x3
        }

        function drawEnemyBullet(bullet) {
            ctx.fillStyle = '#FF3333'; // Brighter red for better visibility
            ctx.shadowColor = '#FF3333';
            ctx.shadowBlur = 8; // Increased for visibility
            ctx.fillRect(bullet.x - 3, bullet.y - 1.5, 6, 3); // Larger bullet: 6x3
        }

        function drawParticle(particle) {
            ctx.fillStyle = `rgba(255, 255, 255, ${particle.life / 30})`;
            ctx.shadowBlur = 0;
            ctx.fillRect(particle.x - 1, particle.y - 1, 2, 2);
        }

        function drawStars() {
            ctx.shadowBlur = 0;
            for (let star of stars) {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }
        }

        function wrap(obj) {
            // Adjusted to keep objects fully within canvas
            const buffer = obj.size || obj.radius || 0;
            if (obj.x < -buffer) obj.x = canvas.width + buffer;
            if (obj.x > canvas.width + buffer) obj.x = -buffer;
            if (obj.y < -buffer) obj.y = canvas.height + buffer;
            if (obj.y > canvas.height + buffer) obj.y = -buffer;
        }

        function checkCollision(x1, y1, r1, x2, y2, r2) {
            return Math.hypot(x1 - x2, y1 - y2) < r1 + r2;
        }

        function handlePlayerDeath() {
            playShipExplosionSound();
            createParticles(ship.x, ship.y, 20);
            game.lives--;
            if (game.lives <= 0) {
                game.gameOver = true;
                document.getElementById('gameOver').style.display = 'block';
                stopThrustSound();
            } else {
                ship.x = canvas.width / (2 * (window.devicePixelRatio || 1));
                ship.y = canvas.height / (2 * (window.devicePixelRatio || 1));
                ship.vx = 0;
                ship.vy = 0;
                ship.angle = -Math.PI / 2;
                game.invulnerable = 90;
                stopThrustSound();
                ship.wasThrusting = false;
            }
        }

        function updateStars() {
            for (let star of stars) {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            }
        }

        function update() {
            if (game.gameOver) {
                if (thrustOscillator) stopThrustSound();
                lastRumble = 0;
                return;
            }

            updateStars();

            if (keys['ArrowLeft'] || touchControls.left) {
                ship.angle -= 0.08;
            }
            if (keys['ArrowRight'] || touchControls.right) {
                ship.angle += 0.08;
            }
            if (keys['ArrowUp'] || touchControls.thrust) {
                ship.thrust = true;
                ship.thrusting++;
                ship.vx += Math.cos(ship.angle) * 0.15;
                ship.vy += Math.sin(ship.angle) * 0.15;
                if (!ship.wasThrusting) {
                    startThrustSound();
                    ship.wasThrusting = true;
                }
            } else {
                ship.thrust = false;
                ship.thrusting = 0;
                if (ship.wasThrusting) {
                    stopThrustSound();
                    ship.wasThrusting = false;
                }
            }

            if (!ship.thrust) {
                lastRumble++;
                if (lastRumble > RUMBLE_DELAY) {
                    playRumbleSound();
                    lastRumble = 0;
                }
            } else {
                lastRumble = 0;
            }

            if ((keys['ArrowDown'] || touchControls.hyper) && !touchControls.hyperUsed) {
                playHyperspaceSound();
                ship.x = Math.random() * canvas.width;
                ship.y = Math.random() * canvas.height;
                ship.vx = 0;
                ship.vy = 0;
                touchControls.hyper = false;
                touchControls.hyperUsed = true;
                game.invulnerable = 60;
            }
            if (!touchControls.hyper) {
                touchControls.hyperUsed = false;
            }

            if ((keys[' '] || touchControls.fire) && Date.now() - lastShot > shotDelay) {
                playLaserSound();
                bullets.push({
                    x: ship.x + Math.cos(ship.angle) * 15,
                    y: ship.y + Math.sin(ship.angle) * 15,
                    vx: Math.cos(ship.angle) * 8 + ship.vx,
                    vy: Math.sin(ship.angle) * 8 + ship.vy,
                    life: 60,
                    radius: 3 // Increased radius for collision detection
                });
                lastShot = Date.now();
            }

            ship.vx *= 0.99;
            ship.vy *= 0.99;
            const maxSpeed = 8;
            const speed = Math.hypot(ship.vx, ship.vy);
            if (speed > maxSpeed) {
                ship.vx = (ship.vx / speed) * maxSpeed;
                ship.vy = (ship.vy / speed) * maxSpeed;
            }

            ship.x += ship.vx;
            ship.y += ship.vy;
            wrap(ship);

            if (game.invulnerable > 0) game.invulnerable--;

            saucerSpawnTimer++;
            if (saucerSpawnTimer > SAUCER_SPAWN_INTERVAL && saucers.length === 0) {
                spawnSaucer();
                saucerSpawnTimer = 0;
            }

            for (let i = saucers.length - 1; i >= 0; i--) {
                const saucer = saucers[i];
                saucer.x += saucer.vx;
                saucer.y += saucer.vy;
                if (saucer.x < -50 || saucer.x > canvas.width + 50 || saucer.y < -50 || saucer.y > canvas.height + 50) {
                    saucers.splice(i, 1);
                    continue;
                }
                saucer.lastShot++;
                if (saucer.lastShot % Math.max(saucer.shotDelay, 10) === 0) {
                    const angle = Math.atan2(ship.y - saucer.y, ship.x - saucer.x);
                    const spread = (Math.random() - 0.5) * 0.1;
                    const bulletSpeed = 5;
                    enemyBullets.push({
                        x: saucer.x,
                        y: saucer.y,
                        vx: Math.cos(angle + spread) * bulletSpeed,
                        vy: Math.sin(angle + spread) * bulletSpeed,
                        life: 90,
                        radius: 3 // Increased radius for collision detection
                    });
                    playEnemyLaserSound();
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const enemyBullet = enemyBullets[i];
                enemyBullet.x += enemyBullet.vx;
                enemyBullet.y += enemyBullet.vy;
                enemyBullet.life--;
                if (enemyBullet.life <= 0 || enemyBullet.x < 0 || enemyBullet.x > canvas.width || enemyBullet.y < 0 || enemyBullet.y > canvas.height) {
                    enemyBullets.splice(i, 1);
                    continue;
                }
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].vx;
                bullets[i].y += bullets[i].vy;
                bullets[i].life--;
                wrap(bullets[i]);
                if (bullets[i].life <= 0) {
                    bullets.splice(i, 1);
                    continue;
                }
                let bulletRemoved = false;
                for (let j = saucers.length - 1; j >= 0; j--) {
                    if (checkCollision(bullets[i].x, bullets[i].y, bullets[i].radius, saucers[j].x, saucers[j].y, saucers[j].radius)) {
                        playExplosionSound(50);
                        createParticles(saucers[j].x, saucers[j].y, 15);
                        game.score += 200;
                        saucers.splice(j, 1);
                        bullets.splice(i, 1);
                        bulletRemoved = true;
                        break;
                    }
                }
                if (bulletRemoved) continue;
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    if (checkCollision(bullets[i].x, bullets[i].y, bullets[i].radius, asteroids[j].x, asteroids[j].y, asteroids[j].size)) {
                        playExplosionSound(asteroids[j].size);
                        createParticles(asteroids[j].x, asteroids[j].y, 8);
                        if (asteroids[j].size === 50) {
                            game.score += 20;
                            asteroids.push(createAsteroid(asteroids[j].x, asteroids[j].y, 25));
                            asteroids.push(createAsteroid(asteroids[j].x, asteroids[j].y, 25));
                        } else if (asteroids[j].size === 25) {
                            game.score += 50;
                            asteroids.push(createAsteroid(asteroids[j].x, asteroids[j].y, 12));
                            asteroids.push(createAsteroid(asteroids[j].x, asteroids[j].y, 12));
                        } else {
                            game.score += 100;
                        }
                        asteroids.splice(j, 1);
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }

            for (let i = asteroids.length - 1; i >= 0; i--) {
                asteroids[i].x += asteroids[i].vx;
                asteroids[i].y += asteroids[i].vy;
                asteroids[i].angle += asteroids[i].rotation;
                wrap(asteroids[i]);
                if (game.invulnerable === 0 && checkCollision(ship.x, ship.y, ship.radius, asteroids[i].x, asteroids[i].y, asteroids[i].size)) {
                    handlePlayerDeath();
                    asteroids.splice(i, 1);
                    continue;
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (game.invulnerable === 0 && checkCollision(ship.x, ship.y, ship.radius, enemyBullets[i].x, enemyBullets[i].y, enemyBullets[i].radius)) {
                    handlePlayerDeath();
                    enemyBullets.splice(i, 1);
                    continue;
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].life--;
                wrap(particles[i]);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }

            if (asteroids.length === 0) {
                game.level++;
                initLevel();
            }

            document.getElementById('score').textContent = game.score;
            document.getElementById('lives').textContent = game.lives;
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars();
            drawShip();
            asteroids.forEach(drawAsteroid);
            bullets.forEach(drawBullet);
            enemyBullets.forEach(drawEnemyBullet);
            saucers.forEach(drawSaucer);
            particles.forEach(drawParticle);
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        initStars();
        initLevel();
        gameLoop();
    </script>
</body>
</html>